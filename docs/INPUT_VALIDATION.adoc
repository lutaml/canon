---
layout: default
title: Input Validation
nav_order: 33
parent: Customizing Behavior
---
= Canon input validation
:toc:
:toclevels: 3

== Scope

This document describes Canon's input validation system for XML, HTML, JSON,
and YAML formats. Validation ensures malformed input is detected early with
clear error messages.

For format support details, see link:FORMATS[Format support].

== General

Canon validates input before processing and raises `Canon::ValidationError`
for malformed input. Validation provides:

* **Early error detection**: Problems caught before processing begins
* **Precise error location**: Line and column numbers pinpoint the problem
* **Clear error messages**: Descriptive messages explain what's wrong
* **Test-friendly**: Errors appear in RSpec output, not hidden in log files

== How validation works

Canon validates input **before parsing** using format-specific validators:

* `Canon::Validators::XmlValidator` - Strict XML syntax validation
* `Canon::Validators::HtmlValidator` - HTML5 and XHTML validation
* `Canon::Validators::JsonValidator` - JSON syntax validation
* `Canon::Validators::YamlValidator` - YAML syntax validation

Validation happens automatically when you use Canon's formatters or
comparison methods.

== Validation error format

When validation fails, Canon raises `Canon::ValidationError` with:

`format`:: The format being validated (`:xml`, `:html`, `:json`, `:yaml`)
`line`:: Line number where the error occurred (if available)
`column`:: Column number where the error occurred (if available)
`details`:: Additional context about the error

.Validation error structure
[example]
====
[source,ruby]
----
begin
  Canon.format(malformed_xml, :xml)
rescue Canon::ValidationError => e
  puts e.message
  # => XML Validation Error: Premature end of data in tag unclosed line 1
  #    Line: 1
  #    Column: 18

  puts "Format: #{e.format}"     # => :xml
  puts "Line: #{e.line}"          # => 1
  puts "Column: #{e.column}"      # => 18
end
----
====

== Format-specific validation

=== XML validation

Uses Nokogiri's strict XML parsing to detect:

* Unclosed tags
* Mismatched tags
* Invalid XML declaration
* Malformed attributes
* Invalid character references

.XML validation examples
[example]
====
**Unclosed tag**:

[source,ruby]
----
Canon.format('<root><item>', :xml)
# => Canon::ValidationError: XML Validation Error: Premature end of data in tag item line 1
#    Line: 1
----

**Mismatched tags**:

[source,ruby]
----
Canon.format('<root><item></root>', :xml)
# => Canon::ValidationError: XML Validation Error: Opening and ending tag mismatch: item line 1 and root
#    Line: 1
----

**Invalid character reference**:

[source,ruby]
----
Canon.format('<root>&#xGGGG;</root>', :xml)
# => Canon::ValidationError: XML Validation Error: xmlParseCharRef: invalid hexadecimal value
#    Line: 1
----
====

=== HTML validation

Automatically detects HTML5 vs XHTML and applies appropriate validation:

* **HTML5**: Uses Nokogiri::HTML5 parser with error filtering
* **XHTML**: Uses strict XML parsing

**Special handling**:

* Strips XML declarations from HTML (common in legacy HTML files)
* Filters out non-critical HTML5 parser warnings
* Only reports significant errors (level 2+)

.HTML validation examples
[example]
====
**Malformed XHTML**:

[source,ruby]
----
xhtml = '<html xmlns="http://www.w3.org/1999/xhtml"><body><p>Unclosed'
Canon.format(xhtml, :html)
# => Canon::ValidationError: HTML Validation Error: Premature end of data in tag p line 1
#    Line: 1
----

**HTML5 with errors**:

[source,ruby]
----
html5 = '<div><span></div>'
Canon.format(html5, :html)
# => Canon::ValidationError: HTML Validation Error: Unexpected end tag : span
#    Line: 1
----

**Valid HTML** (no error):

[source,ruby]
----
html = '<!DOCTYPE html><html><body><p>Content</p></body></html>'
Canon.format(html, :html)
# => Successfully formatted
----
====

=== JSON validation

Validates JSON syntax using Ruby's JSON parser:

* Missing/extra braces or brackets
* Trailing commas
* Invalid escape sequences
* Invalid numbers

Provides context showing the error location in the JSON structure.

.JSON validation examples
[example]
====
**Missing closing brace**:

[source,ruby]
----
Canon.format('{"key": "value"', :json)
# => Canon::ValidationError: JSON Validation Error: unexpected token at '{"key": "value"'
#    Details: Error at position 16
----

**Trailing comma** (invalid in JSON):

[source,ruby]
----
Canon.format('{"a": 1,}', :json)
# => Canon::ValidationError: JSON Validation Error: unexpected token at '{"a": 1,}'
#    Details: Error at position 8
----

**Invalid number**:

[source,ruby]
----
Canon.format('{"value": 01}', :json)
# => Canon::ValidationError: JSON Validation Error: unexpected token
----

**Valid JSON** (no error):

[source,ruby]
----
Canon.format('{"key": "value"}', :json)
# => Successfully formatted
----
====

=== YAML validation

Validates YAML syntax using Psych (Ruby's YAML parser):

* Invalid indentation
* Unclosed brackets/braces
* Invalid anchors/aliases
* Type mismatches

Shows error location with line numbers and context.

.YAML validation examples
[example]
====
**Unclosed bracket**:

[source,ruby]
----
Canon.format("key: {unclosed", :yaml)
# => Canon::ValidationError: YAML Validation Error: (<unknown>): did not find expected node content...
#    Line: 1
#    Details: Shows context around error
----

**Invalid indentation**:

[source,ruby]
----
yaml = <<~YAML
  parent:
  child: value
YAML
Canon.format(yaml, :yaml)
# => Canon::ValidationError: YAML Validation Error: mapping values are not allowed in this context
#    Line: 2
----

**Valid YAML** (no error):

[source,ruby]
----
yaml = "key: value\nlist:\n  - item1\n  - item2"
Canon.format(yaml, :yaml)
# => Successfully formatted
----
====

== Validation in RSpec tests

Canon's RSpec matchers automatically propagate validation errors to test
output, making it easy to see what's wrong.

.RSpec validation error example
[example]
====
[source,ruby]
----
require 'canon/rspec_matchers'

RSpec.describe 'XML validation' do
  it 'validates input' do
    malformed_xml = '<root><unclosed>'
    expected_xml = '<root><item/></root>'

    # This will fail with a clear validation error message
    expect(malformed_xml).to be_xml_equivalent_to(expected_xml)
  end
end

# Test output shows:
# Canon::ValidationError:
#   XML Validation Error: Premature end of data in tag unclosed line 1
#     Line: 1
#     Column: 18
----

The error appears directly in the RSpec output, not hidden in separate error
files or logs.
====

== Validation in comparison

Validation also occurs when using `Canon::Comparison.equivalent?`:

.Comparison validation example
[example]
====
[source,ruby]
----
require 'canon/comparison'

xml1 = '<root><item/></root>'
xml2 = '<root><unclosed>'

Canon::Comparison.equivalent?(xml1, xml2)
# => Canon::ValidationError: XML Validation Error: Premature end of data in tag unclosed line 1
#    Line: 1
#    Column: 18
----
====

== Error handling strategies

=== Basic error handling

[source,ruby]
----
begin
  Canon.format(input, :xml)
rescue Canon::ValidationError => e
  puts "Validation failed: #{e.message}"
  puts "Line #{e.line}, Column #{e.column}" if e.line
end
----

=== Format-specific handling

[source,ruby]
----
begin
  Canon.format(input, format)
rescue Canon::ValidationError => e
  case e.format
  when :xml
    handle_xml_error(e)
  when :html
    handle_html_error(e)
  when :json
    handle_json_error(e)
  when :yaml
    handle_yaml_error(e)
  end
end
----

=== Validation before processing

[source,ruby]
----
def process_xml(xml_string)
  # Validate early
  begin
    Canon.format(xml_string, :xml)
  rescue Canon::ValidationError => e
    log_validation_error(e)
    return { error: e.message, line: e.line }
  end

  # Proceed with processing
  process_valid_xml(xml_string)
end
----

== Common validation errors

=== XML common errors

[cols="1,2,1"]
|===
|Error |Cause |Solution

|Premature end of data
|Unclosed tag
|Close all tags

|Tag mismatch
|Opening/closing tags don't match
|Match tag names exactly

|Invalid character reference
|Bad entity or character code
|Use valid entities

|Invalid XML declaration
|Malformed `<?xml...?>` tag
|Fix or remove declaration
|===

=== HTML common errors

[cols="1,2,1"]
|===
|Error |Cause |Solution

|Unexpected end tag
|Mismatched or extra closing tag
|Match opening/closing tags

|Invalid DOCTYPE
|Malformed document type declaration
|Use standard DOCTYPE

|Unclosed tag
|Missing closing tag
|Close all tags properly

|Invalid attribute
|Malformed attribute syntax
|Fix attribute syntax
|===

=== JSON common errors

[cols="1,2,1"]
|===
|Error |Cause |Solution

|Unexpected token
|Syntax error in JSON
|Check JSON syntax

|Trailing comma
|Comma after last element
|Remove trailing commas

|Unclosed bracket/brace
|Missing `]` or `}`
|Close all brackets/braces

|Invalid number
|Leading zeros or invalid format
|Use valid number format
|===

=== YAML common errors

[cols="1,2,1"]
|===
|Error |Cause |Solution

|Invalid indentation
|Inconsistent indentation
|Use consistent spaces

|Unclosed bracket
|Missing closing bracket
|Close all brackets

|Invalid anchor
|Malformed anchor/alias
|Fix anchor syntax

|Type mismatch
|Value doesn't match expected type
|Fix value or type
|===

== Benefits

**Early error detection**:: Problems caught before processing begins, saving
time and providing clear feedback

**Precise error location**:: Line and column numbers pinpoint exactly where
the problem is, especially useful in large documents

**Clear error messages**:: Descriptive messages explain what's wrong and
often suggest how to fix it

**Test-friendly**:: Errors appear in RSpec output where developers expect
them, not in separate log files

**Format-aware**:: Each validator understands format-specific rules and
provides relevant error details

== See also

* link:FORMATS[Format support]
* link:RUBY_API[Ruby API documentation]
* link:RSPEC[RSpec matchers]
* link:CLI[Command-line interface]
