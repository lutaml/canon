= Canon: Canonicalization for serialization formats

A Ruby library for canonicalizing and pretty-printing XML, HTML, YAML, and JSON
with RSpec matchers for equivalence testing.


== Purpose

Canon provides canonicalization and pretty-printing for various serialization
formats (XML, HTML, JSON, YAML), producing standardized forms suitable for
comparison, testing, digital signatures, and human-readable output.


== Features

=== Ruby API

Single API for working with all four formats (XML, HTML, JSON, YAML).


=== XML canonicalization

Format XML documents according to the
https://www.w3.org/TR/xml-c14n11/[W3C Canonical XML Version 1.1] specification.

Key features:

* Namespace declaration ordering (lexicographic by prefix)
* Attribute ordering (lexicographic by namespace URI, then local name)
* Character encoding normalization to UTF-8
* Special character encoding in text and attributes
* Removal of superfluous namespace declarations
* Support for xml:base, xml:lang, xml:space, and xml:id attributes
* Processing instruction and comment handling
* Document subset support with attribute inheritance

=== HTML canonicalization

Format HTML 4/5 and XHTML documents with consistent formatting. Automatically
detects HTML vs XHTML and applies appropriate formatting.

=== YAML canonicalization

Format YAML documents with keys sorted alphabetically at all levels of the
structure.

=== JSON canonicalization

Format JSON documents with keys sorted alphabetically at all levels of the
structure.


=== Output modes

Canon supports two output modes for all formats:

`c14n` (canonical):: Compact output without indentation, suitable for digital
signatures, hashing, and equivalence testing. Removes formatting whitespace.

`pretty` (pretty-print):: Human-readable output with consistent indentation.
Configurable indent size and type (spaces or tabs). This is the default mode for
CLI commands.


=== RSpec matchers

Provides matchers for testing equivalence between serialized formats.

NOTE: RSpec matchers always use canonical (c14n) mode for comparison to ensure
formatting differences don't affect test results.

=== Comparison API

Canon provides a `Canon::Comparison` module for semantic comparison of HTML and
XML documents.

The `Canon::Comparison.equivalent?` method compares two documents for semantic
equivalence, ignoring formatting differences that don't affect meaning.

Key features:

* Semantic comparison (content, not formatting)
* Whitespace normalization
* Comment handling (can ignore or include)
* Attribute sorting
* Support for both HTML and XML documents
* Optional verbose diff output

NOTE: `Canon::Comparison.equivalent?` adopts option names used by the excellent
https://github.com/vkononov/compare-xml[`compare-xml` gem].


== Installation

Add this line to your application's Gemfile:

[source,ruby]
----
gem 'canon'
----

And then execute:

[source,bash]
----
$ bundle install
----

Or install it yourself as:

[source,bash]
----
$ gem install canon
----


== Usage

=== Ruby API

==== Basic formatting (c14n mode)

The `Canon.format` method produces canonical output by default.

Syntax:

[source,ruby]
----
Canon.format({content}, {format})
Canon.format_{format}({content})  # Format-specific shorthand
----

Where,

`{content}`:: The input string
`{format}`:: The format type (`:xml`, `:html`, `:json`, or `:yaml`)

.Canonical formatting examples
[example]
====
[source,ruby]
----
require 'canon'

# XML - compact canonical form
xml = '<root><b>2</b><a>1</a></root>'
Canon.format(xml, :xml)
# => "<root><a>1</a><b>2</b></root>"

Canon.format_xml(xml)  # Shorthand
# => "<root><a>1</a><b>2</b></root>"

# HTML - compact canonical form
html = '<div><p>Hello</p></div>'
Canon.format(html, :html)
Canon.format_html(html)  # Shorthand

# JSON - canonical with sorted keys
json = '{"z":3,"a":1,"b":2}'
Canon.format(json, :json)
# => {"a":1,"b":2,"z":3}

# YAML - canonical with sorted keys
yaml = "z: 3\na: 1\nb: 2"
Canon.format(yaml, :yaml)
----
====

==== Pretty-print mode

For human-readable output with indentation, use the format-specific pretty
printer classes.

Syntax:

[source,ruby]
----
Canon::{Format}::PrettyPrinter.new(indent: {n}, indent_type: {type}).format({content})
----

Where,

`{Format}`:: The format module (`Xml`, `Html`, `Json`)
`{n}`:: Number of spaces (default: 2) or tabs (use 1 for tabs)
`{type}`:: Indentation type: `'space'` (default) or `'tab'`
`{content}`:: The input string

.Pretty-print examples
[example]
====
[source,ruby]
----
require 'canon/xml/pretty_printer'
require 'canon/html/pretty_printer'
require 'canon/json/pretty_printer'

xml_input = '<root><b>2</b><a>1</a></root>'

# XML with 2-space indentation (default)
Canon::Xml::PrettyPrinter.new(indent: 2).format(xml_input)
# =>
# <?xml version="1.0" encoding="UTF-8"?>
# <root>
#   <a>1</a>
#   <b>2</b>
# </root>

# XML with 4-space indentation
Canon::Xml::PrettyPrinter.new(indent: 4).format(xml_input)

# XML with tab indentation
Canon::Xml::PrettyPrinter.new(
  indent: 1,
  indent_type: 'tab'
).format(xml_input)

# HTML with 2-space indentation
html_input = '<div><p>Hello</p></div>'
Canon::Html::PrettyPrinter.new(indent: 2).format(html_input)

# JSON with 2-space indentation
json_input = '{"z":3,"a":{"b":1}}'
Canon::Json::PrettyPrinter.new(indent: 2).format(json_input)

# JSON with tab indentation
Canon::Json::PrettyPrinter.new(
  indent: 1,
  indent_type: 'tab'
).format(json_input)
----
====

==== Parsing

The `Canon.parse` method parses content into Ruby objects or Nokogiri documents.

Syntax:

[source,ruby]
----
Canon.parse({content}, {format})
Canon.parse_{format}({content})  # Format-specific shorthand
----

Where,

`{content}`:: The input string
`{format}`:: The format type (`:xml`, `:html`, `:json`, or `:yaml`)

.Parsing examples
[example]
====
[source,ruby]
----
# Parse XML → Nokogiri::XML::Document
xml_doc = Canon.parse(xml_input, :xml)
xml_doc = Canon.parse_xml(xml_input)

# Parse HTML → Nokogiri::HTML5::Document (or XML::Document for XHTML)
html_doc = Canon.parse(html_input, :html)
html_doc = Canon.parse_html(html_input)

# Parse JSON → Ruby Hash/Array
json_obj = Canon.parse(json_input, :json)
json_obj = Canon.parse_json(json_input)

# Parse YAML → Ruby Hash/Array
yaml_obj = Canon.parse(yaml_input, :yaml)
yaml_obj = Canon.parse_yaml(yaml_input)
----
====

==== Comparison

===== General

The `Canon::Comparison.equivalent?` method compares two HTML or XML documents.

The Comparison module uses a depth-first comparison based on the two DOM trees
by traversing them in parallel and comparing nodes.

In XML mode:

* Parsing: accepts Moxml (`Moxml::Document`) or Nokogiri
(`Nokogiri::XML::Document`)
* Comments: normalized and compared unless `ignore_comments: true`
* Whitespace: collapses whitespace in text nodes unless `collapse_whitespace: false`
* Sorts attributes alphabetically before comparison

In HTML mode:

* Parsing: accepts Nokogiri (`Nokogiri::HTML5` or `Nokogiri::HTML`)
* Normalizes HTML comments in `<style>` and `<script>` tags
* Sorts attributes alphabetically before comparison
* Collapses whitespace for text content comparison
* Removes empty text nodes between elements

[NOTE]
====
The comparison module is automatically used by Canon's RSpec matchers
(`be_html_equivalent_to`, `be_xml_equivalent_to`, etc.) to provide reliable
semantic comparison in tests.
====

===== Basic usage

Syntax:

[source,ruby]
----
Canon::Comparison.equivalent?({doc1}, {doc2}, {options})
----

Where,

`{doc1}`:: First document object (String, Nokogiri::HTML::Document, or supported XML document)
`{doc2}`:: Second document object (String, Nokogiri::HTML::Document, or supported XML document)
`{options}`:: Hash of comparison options (optional)

Canon::Comparison for XML supports Moxml::Document and Nokogiri::XML::Document
as input.

Returns:

* `true` if documents are equivalent
* `false` if documents differ
* `Array` of differences if `verbose: true` option is set

.Basic comparison examples
[example]
====
[source,ruby]
----
require 'canon/comparison'

# HTML comparison - ignores whitespace and comments by default
html1 = '<div><p>Hello</p></div>'
html2 = '<div> <p> Hello </p> </div>'
Canon::Comparison.equivalent?(html1, html2)
# => true

# HTML with different content
html3 = '<div><p>Goodbye</p></div>'
Canon::Comparison.equivalent?(html1, html3)
# => false

# XML comparison
xml1 = '<root><a>1</a><b>2</b></root>'
xml2 = '<root>  <b>2</b>  <a>1</a>  </root>'
Canon::Comparison.equivalent?(xml1, xml2)
# => true

# With Nokogiri documents
doc1 = Nokogiri::HTML5(html1)
doc2 = Nokogiri::HTML5(html2)
Canon::Comparison.equivalent?(doc1, doc2)
# => true
----
====



===== Options at a glance

The `Canon::Comparison.equivalent?` method has a variety of options that tailor
comparison behavior.

The following options control comparison behavior:

`collapse_whitespace`:: (default: `true`) when `true`, trims and collapses whitespace
(<<collapse_whitespace>>)

`ignore_comments`:: (default: `true`) when `true`, ignores HTML/XML comments
(<<ignore_comments>>)

`ignore_attr_order`:: (default: `true`) when `true`, ignores attribute ordering
(<<ignore_attr_order>>)

`ignore_text_nodes`:: (default: `false`) when `true`, ignores all text content
(<<ignore_text_nodes>>)

`verbose`:: (default: `false`) when `true`, returns array of differences instead of boolean
(<<verbose>>)


[[collapse_whitespace]]
==== collapse_whitespace

`collapse_whitespace: {true|false}` default: `true`

When `true`, all text content within the document is trimmed (i.e. space removed
from left and right) and whitespace is collapsed (i.e. tabs, new lines, multiple
whitespace characters are replaced by a single whitespace).

XML mode:: Whitespace is collapsed in text nodes only. Whitespace within
attribute values is preserved.

HTML mode:: Whitespace is collapsed in text nodes only. Whitespace within
attribute values is preserved. Additionally, empty text nodes between elements
are removed.

Usage:

[source,ruby]
----
Canon::Comparison.equivalent?(doc1, doc2, collapse_whitespace: true)
----

.HTML examples with collapse_whitespace
[example]
====
When `true` the following HTML strings are considered equal:

[source,html]
----
<a href="/admin">   SOME TEXT CONTENT   </a>
<a href="/admin">SOME    TEXT    CONTENT</a>
----

[source,ruby]
----
html1 = '<a href="/admin">   SOME TEXT CONTENT   </a>'
html2 = '<a href="/admin">SOME    TEXT    CONTENT</a>'
Canon::Comparison.equivalent?(html1, html2, collapse_whitespace: true)
# => true
----

When `true` the following HTML strings are considered equal:

[source,html]
----
<html>
  <title>
    This is my title
  </title>
</html>

<html><title>This is my title</title></html>
----

[source,ruby]
----
html1 = <<~HTML
  <html>
    <title>
      This is my title
    </title>
  </html>
HTML
html2 = '<html><title>This is my title</title></html>'
Canon::Comparison.equivalent?(html1, html2, collapse_whitespace: true)
# => true
----
====

.XML examples with collapse_whitespace
[example]
====
When `true` the following XML strings are considered equal:

[source,xml]
----
<root>
  <item>   Some text   </item>
</root>

<root><item>Some text</item></root>
----

[source,ruby]
----
xml1 = "<root>\n  <item>   Some text   </item>\n</root>"
xml2 = '<root><item>Some text</item></root>'
Canon::Comparison.equivalent?(xml1, xml2, collapse_whitespace: true)
# => true
----
====

[[ignore_attr_order]]
==== ignore_attr_order

`ignore_attr_order: {true|false}` default: `true`

When `true`, all attributes are sorted before comparison and only attributes of
the same type are compared.

Usage:

[source,ruby]
----
Canon::Comparison.equivalent?(doc1, doc2, ignore_attr_order: true)
----

.HTML examples with ignore_attr_order
[example]
====
When `true` the following HTML strings are considered equal:

[source,html]
----
<a href="/admin" class="button" target="_blank">Link</a>
<a class="button" target="_blank" href="/admin">Link</a>
----

[source,ruby]
----
html1 = '<a href="/admin" class="button" target="_blank">Link</a>'
html2 = '<a class="button" target="_blank" href="/admin">Link</a>'
Canon::Comparison.equivalent?(html1, html2, ignore_attr_order: true)
# => true
----

When `false` attributes are compared in order:

[source,ruby]
----
html1 = '<a href="/admin" class="button">Link</a>'
html2 = '<a class="button" href="/admin">Link</a>'
Canon::Comparison.equivalent?(html1, html2, ignore_attr_order: false)
# => false
----
====

.XML examples with ignore_attr_order
[example]
====
When `true` the following XML strings are considered equal:

[source,xml]
----
<item id="1" name="Widget" price="10.00"/>
<item price="10.00" id="1" name="Widget"/>
----

[source,ruby]
----
xml1 = '<item id="1" name="Widget" price="10.00"/>'
xml2 = '<item price="10.00" id="1" name="Widget"/>'
Canon::Comparison.equivalent?(xml1, xml2, ignore_attr_order: true)
# => true
----
====

[[ignore_comments]]
==== ignore_comments

`ignore_comments: {true|false}` default: `true`

When `true`, ignores comments such as `<!-- This is a comment -->`.

Usage:

[source,ruby]
----
Canon::Comparison.equivalent?(doc1, doc2, ignore_comments: true)
----

.HTML examples with ignore_comments
[example]
====
When `true` the following HTML strings are considered equal:

[source,html]
----
<!-- This is a comment -->
<!-- This is another comment -->
----

[source,ruby]
----
html1 = '<!-- This is a comment -->'
html2 = '<!-- This is another comment -->'
Canon::Comparison.equivalent?(html1, html2, ignore_comments: true)
# => true
----

When `true` the following HTML strings are considered equal:

[source,html]
----
<a href="/admin"><!-- This is a comment -->Link</a>
<a href="/admin">Link</a>
----

[source,ruby]
----
html1 = '<a href="/admin"><!-- This is a comment -->Link</a>'
html2 = '<a href="/admin">Link</a>'
Canon::Comparison.equivalent?(html1, html2, ignore_comments: true)
# => true
----

When `false` comments are compared:

[source,ruby]
----
html1 = '<div><!-- comment 1 --><p>Text</p></div>'
html2 = '<div><!-- comment 2 --><p>Text</p></div>'
Canon::Comparison.equivalent?(html1, html2, ignore_comments: false)
# => false
----
====

.XML examples with ignore_comments
[example]
====
When `true` the following XML strings are considered equal:

[source,xml]
----
<root>
  <!-- First comment -->
  <item>Data</item>
</root>

<root>
  <!-- Different comment -->
  <item>Data</item>
</root>
----

[source,ruby]
----
xml1 = '<root><!-- First comment --><item>Data</item></root>'
xml2 = '<root><!-- Different comment --><item>Data</item></root>'
Canon::Comparison.equivalent?(xml1, xml2, ignore_comments: true)
# => true
----
====

[[ignore_text_nodes]]
==== ignore_text_nodes

`ignore_text_nodes: {true|false}` default: `false`

When `true`, ignores all text content. Text content is anything that is included
between an opening and a closing tag, e.g. `<tag>THIS IS TEXT CONTENT</tag>`.

Usage:

[source,ruby]
----
Canon::Comparison.equivalent?(doc1, doc2, ignore_text_nodes: true)
----

.HTML examples with ignore_text_nodes
[example]
====
When `true` the following HTML strings are considered equal:

[source,html]
----
<a href="/admin">SOME TEXT CONTENT</a>
<a href="/admin">DIFFERENT TEXT CONTENT</a>
----

[source,ruby]
----
html1 = '<a href="/admin">SOME TEXT CONTENT</a>'
html2 = '<a href="/admin">DIFFERENT TEXT CONTENT</a>'
Canon::Comparison.equivalent?(html1, html2, ignore_text_nodes: true)
# => true
----

When `true` the following HTML strings are considered equal:

[source,html]
----
<i class="icon"></i><b>Warning:</b>
<i class="icon"></i><b>Message:</b>
----

[source,ruby]
----
html1 = '<i class="icon"></i><b>Warning:</b>'
html2 = '<i class="icon"></i><b>Message:</b>'
Canon::Comparison.equivalent?(html1, html2, ignore_text_nodes: true)
# => true
----

When `false` text content is compared:

[source,ruby]
----
html1 = '<p>Hello</p>'
html2 = '<p>Goodbye</p>'
Canon::Comparison.equivalent?(html1, html2, ignore_text_nodes: false)
# => false
----
====

.XML examples with ignore_text_nodes
[example]
====
When `true` the following XML strings are considered equal:

[source,xml]
----
<item>First value</item>
<item>Second value</item>
----

[source,ruby]
----
xml1 = '<item>First value</item>'
xml2 = '<item>Second value</item>'
Canon::Comparison.equivalent?(xml1, xml2, ignore_text_nodes: true)
# => true
----
====

[[verbose]]
==== verbose

`verbose: {true|false}` default: `false`

When `true`, instead of returning a boolean value `Canon::Comparison.equivalent?`
returns an array of all errors encountered when performing a comparison.

WARNING: When `true`, the comparison takes longer! Not only because more
processing is required to produce meaningful differences, but also because in
this mode, comparison does **NOT** stop when a first difference is encountered,
because the goal is to capture as many differences as possible.

Usage:

[source,ruby]
----
Canon::Comparison.equivalent?(doc1, doc2, verbose: true)
----

Return values in verbose mode:

* Empty array `[]` if documents are equivalent
* Array of difference hashes if documents differ

Each difference hash contains:

`node1`:: The first node involved in the difference
`node2`:: The second node involved in the difference
`diff1`:: Difference code for the first node
`diff2`:: Difference code for the second node

Difference codes:

* `Canon::Comparison::EQUIVALENT` (1) - Nodes are equivalent
* `Canon::Comparison::MISSING_ATTRIBUTE` (2) - Attribute missing
* `Canon::Comparison::MISSING_NODE` (3) - Node missing
* `Canon::Comparison::UNEQUAL_ATTRIBUTES` (4) - Attributes differ
* `Canon::Comparison::UNEQUAL_COMMENTS` (5) - Comments differ
* `Canon::Comparison::UNEQUAL_ELEMENTS` (7) - Element names differ
* `Canon::Comparison::UNEQUAL_NODES_TYPES` (8) - Node types differ
* `Canon::Comparison::UNEQUAL_TEXT_CONTENTS` (9) - Text content differs

.Verbose mode examples
[example]
====
[source,ruby]
----
# Verbose mode with equivalent documents
html1 = '<div>Hello</div>'
html2 = '<div>Hello</div>'
result = Canon::Comparison.equivalent?(html1, html2, verbose: true)
# => [] (empty array indicates equivalence)

# Verbose mode with different text content
html1 = '<div>Hello</div>'
html2 = '<div>Goodbye</div>'
result = Canon::Comparison.equivalent?(html1, html2, verbose: true)
# => [{
#   node1: <Nokogiri::XML::Text>,
#   node2: <Nokogiri::XML::Text>,
#   diff1: 9,  # UNEQUAL_TEXT_CONTENTS
#   diff2: 9   # UNEQUAL_TEXT_CONTENTS
# }]

# Verbose mode with different element names
html1 = '<div>Test</div>'
html2 = '<span>Test</span>'
result = Canon::Comparison.equivalent?(html1, html2, verbose: true)
# => [{
#   node1: <Nokogiri::XML::Element: div>,
#   node2: <Nokogiri::XML::Element: span>,
#   diff1: 7,  # UNEQUAL_ELEMENTS
#   diff2: 7   # UNEQUAL_ELEMENTS
# }]

# Verbose mode with missing attributes
html1 = '<div class="foo" id="bar">Test</div>'
html2 = '<div class="foo">Test</div>'
result = Canon::Comparison.equivalent?(html1, html2, verbose: true)
# => [{
#   node1: <Nokogiri::XML::Element: div>,
#   node2: <Nokogiri::XML::Element: div>,
#   diff1: 2,  # MISSING_ATTRIBUTE
#   diff2: 2   # MISSING_ATTRIBUTE
# }]

# Check difference type programmatically
result = Canon::Comparison.equivalent?(html1, html2, verbose: true)
if result.empty?
  puts "Documents are equivalent"
else
  result.each do |diff|
    case diff[:diff1]
    when Canon::Comparison::UNEQUAL_TEXT_CONTENTS
      puts "Text content differs"
    when Canon::Comparison::UNEQUAL_ELEMENTS
      puts "Element names differ"
    when Canon::Comparison::MISSING_ATTRIBUTE
      puts "Attributes differ"
    end
  end
end
----
====


=== Diff formatting configuration

==== General

Canon provides comprehensive diff formatting capabilities across three interfaces:
RSpec matchers, CLI commands, and the Ruby API. All interfaces support the same
set of parameters for consistent behavior.

==== Parameters

The following table shows all available diff formatting parameters and their
availability across interfaces:

[cols="1,1,1,1,2,1"]
|===
|Parameter |RSpec |CLI |Ruby API |Description |Default

|`use_color`
|✓
|✓
|✓
|Enable/disable colored output
|`true`

|`diff_mode`
|✓
|✓
|✓
|Comparison mode: `:by_object` or `:by_line`
|`:by_line` (RSpec), `:by_object` (XML/JSON/YAML)

|`context_lines`
|✓
|✓
|✓
|Number of unchanged lines to show around each change
|`3`

|`diff_grouping_lines`
|✓
|✓
|✓
|Maximum line distance to group separate diffs into context blocks
|`10`
|===

==== Interface-specific usage

===== RSpec matchers configuration

Configure diff formatting for RSpec matchers using `Canon::RspecMatchers`:

[source,ruby]
----
require 'canon/rspec_matchers'

# Configure globally for all matchers
Canon::RspecMatchers.diff_mode = :by_object
Canon::RspecMatchers.use_color = true
Canon::RspecMatchers.context_lines = 5
Canon::RspecMatchers.diff_grouping_lines = 10

# Use in specs
RSpec.describe 'My comparison' do
  it 'shows formatted diff' do
    expect(actual_xml).to be_xml_equivalent_to(expected_xml)
  end
end
----

===== CLI usage

Pass options to the `canon diff` command:

[source,bash]
----
# Basic diff with default settings
$ canon diff file1.xml file2.xml --verbose

# Customize diff output
$ canon diff file1.xml file2.xml \
  --verbose \
  --by-line \
  --no-color \
  --context-lines 5 \
  --diff-grouping-lines 10
----

===== Ruby API usage

Use `Canon::DiffFormatter` directly in your code:

[source,ruby]
----
require 'canon/diff_formatter'
require 'canon/comparison'

# Compare documents
comparison = Canon::Comparison.new(doc1, doc2)
result = comparison.compare

# Format diff output
formatter = Canon::DiffFormatter.new(
  use_color: true,
  mode: :by_object,
  context_lines: 5,
  diff_grouping_lines: 10
)

diff_output = formatter.format(result)
puts diff_output
----

==== Parameter details

===== use_color

Controls whether diff output includes ANSI color codes.

* Type: Boolean
* Default: `true`
* Colors used:
  ** Red: Deletions/removed content
  ** Green: Additions/inserted content
  ** Yellow: Modified content
  ** Cyan: Element names and structure

[source,ruby]
----
# Disable colors for plain text output
Canon::RspecMatchers.use_color = false

# CLI
$ canon diff file1.xml file2.xml --no-color --verbose
----

===== diff_mode

Determines the comparison and display strategy.

* Type: Symbol (`:by_object` or `:by_line`)
* Default: `:by_line` for RSpec matchers, format-dependent for CLI/API
* Modes:
  ** `:by_object` - Semantic tree-based comparison showing structural changes
  ** `:by_line` - Line-by-line diff after canonicalization

[source,ruby]
----
# Use object-based diff for RSpec matchers
Canon::RspecMatchers.diff_mode = :by_object

# CLI - XML uses by-object by default, force by-line
$ canon diff file1.xml file2.xml --by-line --verbose
----

===== context_lines

Number of unchanged lines to display around each change for context.

* Type: Numeric
* Default: `3`
* Range: `0` to any positive integer
* Effect: Higher values show more surrounding context, lower values show only changes

[source,ruby]
----
# Show 5 lines of context around each change
Canon::RspecMatchers.context_lines = 5

# CLI
$ canon diff file1.xml file2.xml --context-lines 5 --verbose

# Ruby API
formatter = Canon::DiffFormatter.new(context_lines: 5)
----

===== diff_grouping_lines

Maximum line distance between separate changes to group them into a single
context block.

* Type: Numeric or `nil`
* Default: `nil` (no grouping)
* Effect: When set, changes within N lines of each other are grouped into
context blocks with a header showing the number of diffs in the block

[source,ruby]
----
# Group changes that are within 10 lines of each other
Canon::RspecMatchers.diff_grouping_lines = 10

# CLI
$ canon diff file1.xml file2.xml --diff-grouping-lines 10 --verbose

# Ruby API
formatter = Canon::DiffFormatter.new(diff_grouping_lines: 10)
----

.Example of grouped diff output
[example]
When `diff_grouping_lines` is set to `10`, changes close together are grouped:

[source]
----
Context block has 3 diffs (lines 5-18):
   5 - |     <foreword id="fwd">
   5 + |     <foreword displayorder="2" id="fwd">
   6   |       <p>First paragraph</p>
   ...
  15 - |     <title>Scope</title>
  15 + |     <title>Application Scope</title>
  16   |     </clause>
  17 + |     <p>New content</p>
  18   |   </sections>
----

Without grouping, these would appear as separate diff sections.

=== RSpec matchers

RSpec matchers for testing equivalence between serialized formats. All matchers
use canonical (c14n) mode for comparison.

See <<Diff formatting configuration>> for details on configuring diff output
in RSpec matchers.

.RSpec matcher examples
[example]
====
[source,ruby]
----
require 'rspec'
require 'canon'

RSpec.describe 'Serialization equivalence' do
  # Unified matcher with format parameter
  it 'compares XML' do
    xml1 = '<root><a>1</a><b>2</b></root>'
    xml2 = '<root>  <b>2</b>  <a>1</a>  </root>'
    expect(xml1).to be_serialization_equivalent_to(xml2, format: :xml)
  end

  it 'compares HTML' do
    html1 = '<div><p>Hello</p></div>'
    html2 = '<div> <p> Hello </p> </div>'
    expect(html1).to be_serialization_equivalent_to(html2, format: :html)
  end

  it 'compares JSON' do
    json1 = '{"a":1,"b":2}'
    json2 = '{"b":2,"a":1}'
    expect(json1).to be_serialization_equivalent_to(json2, format: :json)
  end

  it 'compares YAML' do
    yaml1 = "a: 1\nb: 2"
    yaml2 = "b: 2\na: 1"
    expect(yaml1).to be_serialization_equivalent_to(yaml2, format: :yaml)
  end

  # Format-specific matchers
  it 'uses format-specific matchers' do
    expect(xml1).to be_xml_equivalent_to(xml2)    # XML
    expect(xml1).to be_analogous_with(xml2)       # XML (legacy)
    expect(html1).to be_html_equivalent_to(html2) # HTML
    expect(json1).to be_json_equivalent_to(json2) # JSON
    expect(yaml1).to be_yaml_equivalent_to(yaml2) # YAML
  end
end
----
====

[IMPORTANT]
====
RSpec matchers always canonicalize both sides before comparing, so:

* Formatting differences (whitespace, indentation) are ignored
* Attribute order in XML/HTML is normalized
* Key order in JSON/YAML is normalized
* Tests focus on content equality, not formatting
====


== Command-line interface

=== Installation

After installing the gem, the `canon` command will be available:

[source,bash]
----
$ gem install canon
$ canon --help
----

=== Format command

The `format` command formats files in XML, HTML, JSON, or YAML.

==== Output modes

`pretty` (default):: Human-readable output with indentation (2 spaces default)
`c14n`:: Canonical form without indentation

==== Command syntax

[source,bash]
----
canon format FILE [OPTIONS]
----

==== Options

`-f, --format FORMAT`:: Specify format: `xml`, `html`, `json`, or `yaml`
(auto-detected from extension if not specified)

`-m, --mode MODE`:: Output mode: `pretty` (default) or `c14n`

`-i, --indent N`:: Indentation spaces for pretty mode (default: 2)

`--indent-type TYPE`:: Indentation type: `space` (default) or `tab`

`-o, --output FILE`:: Write output to file instead of stdout

`-c, --with-comments`:: Include comments in canonical XML output

==== Examples

[source,bash]
----
# Pretty-print (default mode)
$ canon format input.xml
<?xml version="1.0" encoding="UTF-8"?>
<root>
  <a>1</a>
  <b>2</b>
</root>

# Canonical mode (compact)
$ canon format input.xml --mode c14n
<root><a>1</a><b>2</b></root>

# Custom indentation
$ canon format input.xml --mode pretty --indent 4
$ canon format input.json --indent 4

# Tab indentation
$ canon format input.xml --indent-type tab
$ canon format input.html --mode pretty --indent-type tab

# Specify format explicitly
$ canon format data.txt --format xml

# Save to file
$ canon format input.xml --output formatted.xml

# Include XML comments in canonical output
$ canon format doc.xml --mode c14n --with-comments

# HTML files
$ canon format page.html
$ canon format page.html --mode c14n
----

==== Format detection

[cols="1,1"]
|===
|File Extension |Detected Format

|`.xml`
|XML

|`.html`, `.htm`
|HTML

|`.json`
|JSON

|`.yaml`, `.yml`
|YAML
|===

=== Diff command

Compare two files using **semantic comparison** that understands the structure of
XML, HTML, JSON, and YAML formats. Unlike traditional text-based diff tools,
`canon diff` compares the meaning and structure of your data, not just the
characters.

==== Command syntax

[source,bash]
----
canon diff FILE1 FILE2 [OPTIONS]
----

==== Diff modes

Canon supports two diff modes optimized for different use cases:

===== by-object mode (default for JSON/YAML)

Compares files **semantically** by their data structure and displays differences
as a visual tree showing what changed in the structure.

Best for::
* Configuration files where you care about what values changed
* API responses where structure matters
* Comparing semantic equivalence across formats

Features::
* Tree visualization with box-drawing characters
* Shows only what changed (additions, removals, modifications)
* Ignores formatting differences automatically
* Color-coded output (red=removed, green=added, yellow=changed)

===== by-line mode (default for HTML, optional for XML)

Compares files **line-by-line** after canonicalization, showing traditional
diff-style output.

Best for::
* HTML markup where line-level changes matter
* Reviewing exact textual differences
* When you need to see the full document context

Features::
* Traditional diff format with line numbers
* Shows before/after for each change
* Better for understanding markup structure changes

[NOTE]
* JSON and YAML always use **by-object** mode
* HTML always uses **by-line** mode
* XML uses **by-object** mode by default, but can use **by-line** with `--by-line`

==== Options

===== Format options

`-f, --format FORMAT`:: Format for both files: `xml`, `html`, `json`, or `yaml`
(auto-detected from extension if not specified)

`--format1 FORMAT`:: Format for first file (when comparing different formats)

`--format2 FORMAT`:: Format for second file (when comparing different formats)

===== Comparison options

`-v, --verbose`:: Show detailed differences in tree format (default: just show
if files differ)

`--by-line`:: Use line-by-line diff for XML (default: by-object mode)

`--collapse-whitespace` / `--no-collapse-whitespace`:: Control whitespace
normalization in text nodes (default: collapse)

`--ignore-attr-order` / `--no-ignore-attr-order`:: Control whether attribute/key
ordering matters (default: ignore order)

`--ignore-comments`:: Ignore XML/HTML comments during comparison (overrides
`--with-comments`)

`--ignore-text-nodes`:: Ignore all text node content, only compare structure

`-c, --with-comments`:: Include comments in comparison (sets `ignore_comments: false`)

===== Output options

`--color` / `--no-color`:: Enable/disable colored output (default: enabled)

==== Examples

===== Basic comparison

[source,bash]
----
# Compare two JSON files (shows if equivalent or different)
$ canon diff config1.json config2.json
Files are semantically different

# Compare two XML files
$ canon diff file1.xml file2.xml
✅ Files are semantically equivalent
----

===== Verbose mode examples

====== JSON comparison (by-object mode)

[example]
Given these two JSON files:

.config1.json
[source,json]
----
{
  "name": "myapp",
  "version": "1.0.0",
  "settings": {
    "debug": true,
    "port": 8080
  }
}
----

.config2.json
[source,json]
----
{
  "version": "2.0.0",
  "name": "myapp",
  "settings": {
    "debug": false,
    "port": 8080
  }
}
----

Running with `--verbose`:

[source,bash]
----
$ canon diff config1.json config2.json --verbose
Visual Diff:
├── settings.debug:
│   ├── - true
│   └── + false
└── version:
    ├── - "1.0.0"
    └── + "2.0.0"
----

The tree shows:
* Key order difference (`version` moved) is ignored
* Only semantic changes are shown: `debug` and `version` values changed

====== XML comparison (by-object mode with DOM-guided semantic matching)

Canon's XML diff uses **hybrid DOM-guided line diff** that semantically matches
elements across documents using identity attributes (such as `id`, `ref`, `name`,
`key`) and element paths. This ensures that corresponding elements are compared
even when they appear at different line positions in the files.

[example]
Given these two XML files:

.document1.xml
[source,xml]
----
<standard-document>
  <preface>
    <foreword id="fwd">
      <p>First paragraph</p>
    </foreword>
  </preface>
  <sections>
    <clause id="scope">
      <title>Scope</title>
    </clause>
  </sections>
</standard-document>
----

.document2.xml
[source,xml]
----
<standard-document>
  <preface>
    <foreword displayorder="2" id="fwd">
      <p>First paragraph</p>
    </foreword>
  </preface>
  <sections>
    <clause id="scope">
      <title>Scope</title>
      <p>New content</p>
    </clause>
  </sections>
</standard-document>
----

Running with `--verbose` using by-object mode (default):

[source,bash]
----
$ canon diff document1.xml document2.xml --verbose
Visual Diff:
├── preface.foreword:
│   └── + displayorder="2"
└── sections.clause.p:
    └── + "New content"
----

The DOM-guided diff shows:

* The `<foreword id="fwd">` elements are **semantically matched** by their `id`
attribute, even though they may be at different positions
* Only the **added** `displayorder` attribute is shown for foreword
* The **added** `<p>` element in clause is shown
* Unchanged content is not displayed

[example]
Example with element matching when positions differ:

.file1.xml
[source,xml]
----
<root>
  <item id="1" name="Widget" price="10.00"/>
  <item id="2" name="Gadget" price="20.00"/>
</root>
----

.file2.xml
[source,xml]
----
<root>
  <item price="20.00" name="Gadget" id="2"/>
  <item id="1" name="Widget" price="15.00"/>
</root>
----

Running with `--verbose`:

[source,bash]
----
$ canon diff file1.xml file2.xml --verbose
Visual Diff:
└── root.item[id="1"].price:
    ├── - "10.00"
    └── + "15.00"
----

The semantic matching shows:

* Elements are matched by `id` attribute (`id="1"` with `id="1"`, `id="2"` with `id="2"`)
* Position changes are ignored (item with `id="2"` moved from second to first)
* Attribute reordering is ignored (price/name order changed)
* Only the semantic change is shown: `price` value changed for item `id="1"`

[NOTE]
DOM-guided semantic matching features:

* **Identity attributes**: Matches elements using `id`, `ref`, `name`, or `key` attributes
* **Element paths**: Uses full element path for matching (e.g., `root.item`)
* **Token-level highlighting**: Shows differences at semantic token level (element
names, attribute names, attribute values)
* **Parent filtering**: Skips parent elements that only differ in children to
avoid redundant output
* **Line range mapping**: Maps DOM elements to exact line ranges in pretty-printed
output for accurate diff display

====== XML comparison (by-line mode)

The `--by-line` option switches to traditional line-by-line diff after
canonicalization, useful when you need to see exact line-level changes.

[example]
Using the previous example files, but with `--by-line`:

[source,bash]
----
$ canon diff document1.xml document2.xml --by-line --verbose
Line-by-line diff:
   4 - |     <foreword id="fwd">
   4 + |     <foreword displayorder="2" id="fwd">
   5   |       <p>First paragraph</p>
  10 + |       <p>New content</p>
  11   |     </clause>
----

The by-line mode shows:

* Traditional diff format with line numbers
* Full line context after canonicalization
* All changes at line level (not semantic level)
* Useful for reviewing exact textual differences

====== YAML comparison (by-object mode)

YAML comparison uses by-object mode to show semantic differences in the data
structure, ignoring formatting and key ordering differences.

[example]
Given these two YAML files:

.config1.yaml
[source,yaml]
----
database:
  host: localhost
  port: 5432
  name: mydb
logging:
  level: info
  format: json
----

.config2.yaml
[source,yaml]
----
logging:
  level: debug
  format: json
database:
  port: 5432
  host: localhost
  name: production
----

Running with `--verbose`:

[source,bash]
----
$ canon diff config1.yaml config2.yaml --verbose
Visual Diff:
├── database.name:
│   ├── - "mydb"
│   └── + "production"
└── logging.level:
    ├── - "info"
    └── + "debug"
----

The by-object mode shows:

* Section reordering (`logging` before `database`) is ignored
* Key reordering within sections (`port` before `host`) is ignored
* Only semantic value changes are displayed
* Tree structure clearly shows the path to each change

===== Comparison options examples

[source,bash]
----
# Include comments in XML comparison
$ canon diff doc1.xml doc2.xml --with-comments --verbose

# Ignore all text content, only compare structure
$ canon diff template1.html template2.html --ignore-text-nodes

# Don't collapse whitespace (exact whitespace comparison)
$ canon diff file1.xml file2.xml --no-collapse-whitespace

# Compare different formats (must have same structure)
$ canon diff config.json config.yaml --format1 json --format2 yaml --verbose
----

===== HTML comparison (by-line mode only)

HTML comparison always uses by-line mode after canonicalization, which is ideal
for reviewing markup structure changes.

[example]
Given these two HTML files:

.page1.html
[source,html]
----
<!DOCTYPE html>
<html>
  <head>
    <title>My Page</title>
  </head>
  <body>
    <div class="header">
      <h1>Welcome</h1>
      <p>Introduction text</p>
    </div>
    <div class="content">
      <p>Main content</p>
    </div>
  </body>
</html>
----

.page2.html
[source,html]
----
<!DOCTYPE html>
<html>
  <head>
    <title>My Updated Page</title>
  </head>
  <body>
    <nav class="header">
      <h1>Welcome</h1>
      <p>Updated introduction</p>
    </nav>
    <div class="content">
      <p>Main content</p>
      <p>Additional paragraph</p>
    </div>
  </body>
</html>
----

Running with `--verbose`:

[source,bash]
----
$ canon diff page1.html page2.html --verbose
Line-by-line diff:
   4 - |     <title>My Page</title>
   4 + |     <title>My Updated Page</title>
   7 - |     <div class="header">
   7 + |     <nav class="header">
   9 - |       <p>Introduction text</p>
   9 + |       <p>Updated introduction</p>
  10 - |     </div>
  10 + |     </nav>
  13 + |       <p>Additional paragraph</p>
  14   |     </div>
----

The line-by-line mode shows:

* Element name changes (`<div>` to `<nav>`)
* Text content changes
* Added elements with proper indentation context
* Line numbers help locate changes in the document

===== Exit codes

* `0` - Files are semantically equivalent
* `1` - Files are semantically different


== Development

After checking out the repo, run `bin/setup` to install dependencies. Then, run
`rake spec` to run the tests. You can also run `bin/console` for an interactive
prompt that will allow you to experiment.


== Contributing

Bug reports and pull requests are welcome on GitHub at
https://github.com/lutaml/canon.


== Copyright and license

Copyright Ribose.
https://opensource.org/licenses/BSD-2-Clause[BSD-2-Clause License].
