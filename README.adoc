= Canon: Canonicalization for serialization formats

A Ruby library for canonicalizing and pretty-printing XML, HTML, YAML, and JSON
with RSpec matchers for equivalence testing.


== Purpose

Canon provides canonicalization and pretty-printing for various serialization
formats (XML, HTML, JSON, YAML), producing standardized forms suitable for
comparison, testing, digital signatures, and human-readable output.


== Features

=== Ruby API

Single API for working with all four formats (XML, HTML, JSON, YAML).


=== XML canonicalization

Format XML documents according to the
https://www.w3.org/TR/xml-c14n11/[W3C Canonical XML Version 1.1] specification.

Key features:

* Namespace declaration ordering (lexicographic by prefix)
* Attribute ordering (lexicographic by namespace URI, then local name)
* Character encoding normalization to UTF-8
* Special character encoding in text and attributes
* Removal of superfluous namespace declarations
* Support for xml:base, xml:lang, xml:space, and xml:id attributes
* Processing instruction and comment handling
* Document subset support with attribute inheritance

=== HTML canonicalization

Format HTML 4/5 and XHTML documents with consistent formatting. Automatically
detects HTML vs XHTML and applies appropriate formatting.

=== YAML canonicalization

Format YAML documents with keys sorted alphabetically at all levels of the
structure.

=== JSON canonicalization

Format JSON documents with keys sorted alphabetically at all levels of the
structure.


=== Output modes

Canon supports two output modes for all formats:

`c14n` (canonical):: Compact output without indentation, suitable for digital
signatures, hashing, and equivalence testing. Removes formatting whitespace.

`pretty` (pretty-print):: Human-readable output with consistent indentation.
Configurable indent size and type (spaces or tabs). This is the default mode for
CLI commands.


=== RSpec matchers

Provides matchers for testing equivalence between serialized formats.

NOTE: RSpec matchers always use canonical (c14n) mode for comparison to ensure
formatting differences don't affect test results.

=== Comparison API

Canon provides a `Canon::Comparison` module for semantic comparison of HTML and
XML documents.

The `Canon::Comparison.equivalent?` method compares two documents for semantic
equivalence, ignoring formatting differences that don't affect meaning.

Key features:

* Semantic comparison (content, not formatting)
* Whitespace normalization
* Comment handling (can ignore or include)
* Attribute sorting
* Support for both HTML and XML documents
* Optional verbose diff output

NOTE: `Canon::Comparison.equivalent?` adopts option names used by the excellent
https://github.com/vkononov/compare-xml[`compare-xml` gem].


== Installation

Add this line to your application's Gemfile:

[source,ruby]
----
gem 'canon'
----

And then execute:

[source,bash]
----
$ bundle install
----

Or install it yourself as:

[source,bash]
----
$ gem install canon
----


== Usage

=== Ruby API

==== Basic formatting (c14n mode)

The `Canon.format` method produces canonical output by default.

Syntax:

[source,ruby]
----
Canon.format({content}, {format})
Canon.format_{format}({content})  # Format-specific shorthand
----

Where,

`{content}`:: The input string
`{format}`:: The format type (`:xml`, `:html`, `:json`, or `:yaml`)

.Canonical formatting examples
[example]
====
[source,ruby]
----
require 'canon'

# XML - compact canonical form
xml = '<root><b>2</b><a>1</a></root>'
Canon.format(xml, :xml)
# => "<root><a>1</a><b>2</b></root>"

Canon.format_xml(xml)  # Shorthand
# => "<root><a>1</a><b>2</b></root>"

# HTML - compact canonical form
html = '<div><p>Hello</p></div>'
Canon.format(html, :html)
Canon.format_html(html)  # Shorthand

# JSON - canonical with sorted keys
json = '{"z":3,"a":1,"b":2}'
Canon.format(json, :json)
# => {"a":1,"b":2,"z":3}

# YAML - canonical with sorted keys
yaml = "z: 3\na: 1\nb: 2"
Canon.format(yaml, :yaml)
----
====

==== Pretty-print mode

For human-readable output with indentation, use the format-specific pretty
printer classes.

Syntax:

[source,ruby]
----
Canon::{Format}::PrettyPrinter.new(indent: {n}, indent_type: {type}).format({content})
----

Where,

`{Format}`:: The format module (`Xml`, `Html`, `Json`)
`{n}`:: Number of spaces (default: 2) or tabs (use 1 for tabs)
`{type}`:: Indentation type: `'space'` (default) or `'tab'`
`{content}`:: The input string

.Pretty-print examples
[example]
====
[source,ruby]
----
require 'canon/xml/pretty_printer'
require 'canon/html/pretty_printer'
require 'canon/json/pretty_printer'

xml_input = '<root><b>2</b><a>1</a></root>'

# XML with 2-space indentation (default)
Canon::Xml::PrettyPrinter.new(indent: 2).format(xml_input)
# =>
# <?xml version="1.0" encoding="UTF-8"?>
# <root>
#   <a>1</a>
#   <b>2</b>
# </root>

# XML with 4-space indentation
Canon::Xml::PrettyPrinter.new(indent: 4).format(xml_input)

# XML with tab indentation
Canon::Xml::PrettyPrinter.new(
  indent: 1,
  indent_type: 'tab'
).format(xml_input)

# HTML with 2-space indentation
html_input = '<div><p>Hello</p></div>'
Canon::Html::PrettyPrinter.new(indent: 2).format(html_input)

# JSON with 2-space indentation
json_input = '{"z":3,"a":{"b":1}}'
Canon::Json::PrettyPrinter.new(indent: 2).format(json_input)

# JSON with tab indentation
Canon::Json::PrettyPrinter.new(
  indent: 1,
  indent_type: 'tab'
).format(json_input)
----
====

==== Parsing

The `Canon.parse` method parses content into Ruby objects or Nokogiri documents.

Syntax:

[source,ruby]
----
Canon.parse({content}, {format})
Canon.parse_{format}({content})  # Format-specific shorthand
----

Where,

`{content}`:: The input string
`{format}`:: The format type (`:xml`, `:html`, `:json`, or `:yaml`)

.Parsing examples
[example]
====
[source,ruby]
----
# Parse XML → Nokogiri::XML::Document
xml_doc = Canon.parse(xml_input, :xml)
xml_doc = Canon.parse_xml(xml_input)

# Parse HTML → Nokogiri::HTML5::Document (or XML::Document for XHTML)
html_doc = Canon.parse(html_input, :html)
html_doc = Canon.parse_html(html_input)

# Parse JSON → Ruby Hash/Array
json_obj = Canon.parse(json_input, :json)
json_obj = Canon.parse_json(json_input)

# Parse YAML → Ruby Hash/Array
yaml_obj = Canon.parse(yaml_input, :yaml)
yaml_obj = Canon.parse_yaml(yaml_input)
----
====

==== Comparison

The `Canon::Comparison.equivalent?` method compares two HTML or XML documents.

The Comparison module uses a depth-first comparison based on the two DOM trees
by traversing them in parallel and comparing nodes.

In XML mode:

* Parsing: accepts Moxml (`Moxml::Document`) or Nokogiri
(`Nokogiri::XML::Document`)
* Comments: normalized and compared unless `ignore_comments: true`
* Whitespace: collapses whitespace in text nodes unless `collapse_whitespace: false`
* Sorts attributes alphabetically before comparison

In HTML mode:

* Parsing: accepts Nokogiri (`Nokogiri::HTML5` or `Nokogiri::HTML`)
* Normalizes HTML comments in `<style>` and `<script>` tags
* Sorts attributes alphabetically before comparison
* Collapses whitespace for text content comparison
* Removes empty text nodes between elements

[NOTE]
====
The comparison module is automatically used by Canon's RSpec matchers
(`be_html_equivalent_to`, `be_xml_equivalent_to`, etc.) to provide reliable
semantic comparison in tests.
====

Syntax:

[source,ruby]
----
Canon::Comparison.equivalent?({doc1}, {doc2}, {options})
----

Where,

`{doc1}`:: First document object (String, Nokogiri::HTML::Document, or supported XML document)
`{doc2}`:: Second document object (String, Nokogiri::HTML::Document, or supported XML document)
`{options}`:: Hash of comparison options (optional)

Canon::Comparison for XML supports Moxml::Document and Nokogiri::XML::Document
as input.

Returns:

* `true` if documents are equivalent
* `false` if documents differ
* `Array` of differences if `verbose: true` option is set

.Comparison examples
[example]
====
[source,ruby]
----
require 'canon/comparison'

# HTML comparison - ignores whitespace and comments
html1 = '<div><p>Hello</p></div>'
html2 = '<div> <p> Hello </p> </div>'
Canon::Comparison.equivalent?(html1, html2)
# => true

# HTML with different content
html3 = '<div><p>Goodbye</p></div>'
Canon::Comparison.equivalent?(html1, html3)
# => false

# XML comparison
xml1 = '<root><a>1</a><b>2</b></root>'
xml2 = '<root>  <b>2</b>  <a>1</a>  </root>'
Canon::Comparison.equivalent?(xml1, xml2)
# => true

# With Nokogiri documents
doc1 = Nokogiri::HTML5(html1)
doc2 = Nokogiri::HTML5(html2)
Canon::Comparison.equivalent?(doc1, doc2)
# => true
----
====


The following options control comparison behavior:

`collapse_whitespace`:: Normalize whitespace in text nodes (default: `true`)
`ignore_comments`:: Ignore HTML/XML comments (default: `true`)
`ignore_attr_order`:: Ignore attribute ordering (default: `true`)
`verbose`:: Return array of differences instead of boolean (default: `false`)

.Using comparison options
[example]
====
[source,ruby]
----
# Keep comments in comparison
html_with_comments = '<!-- comment --><div>text</div>'
html_no_comments = '<div>text</div>'

Canon::Comparison.equivalent?(
  html_with_comments,
  html_no_comments,
  ignore_comments: false
)
# => false (comments are considered)

Canon::Comparison.equivalent?(
  html_with_comments,
  html_no_comments,
  ignore_comments: true  # default
)
# => true (comments are ignored)
----
====


=== RSpec matchers

RSpec matchers for testing equivalence between serialized formats. All matchers
use canonical (c14n) mode for comparison.

.RSpec matcher examples
[example]
====
[source,ruby]
----
require 'rspec'
require 'canon'

RSpec.describe 'Serialization equivalence' do
  # Unified matcher with format parameter
  it 'compares XML' do
    xml1 = '<root><a>1</a><b>2</b></root>'
    xml2 = '<root>  <b>2</b>  <a>1</a>  </root>'
    expect(xml1).to be_serialization_equivalent_to(xml2, format: :xml)
  end

  it 'compares HTML' do
    html1 = '<div><p>Hello</p></div>'
    html2 = '<div> <p> Hello </p> </div>'
    expect(html1).to be_serialization_equivalent_to(html2, format: :html)
  end

  it 'compares JSON' do
    json1 = '{"a":1,"b":2}'
    json2 = '{"b":2,"a":1}'
    expect(json1).to be_serialization_equivalent_to(json2, format: :json)
  end

  it 'compares YAML' do
    yaml1 = "a: 1\nb: 2"
    yaml2 = "b: 2\na: 1"
    expect(yaml1).to be_serialization_equivalent_to(yaml2, format: :yaml)
  end

  # Format-specific matchers
  it 'uses format-specific matchers' do
    expect(xml1).to be_xml_equivalent_to(xml2)    # XML
    expect(xml1).to be_analogous_with(xml2)       # XML (legacy)
    expect(html1).to be_html_equivalent_to(html2) # HTML
    expect(json1).to be_json_equivalent_to(json2) # JSON
    expect(yaml1).to be_yaml_equivalent_to(yaml2) # YAML
  end
end
----
====

[IMPORTANT]
====
RSpec matchers always canonicalize both sides before comparing, so:

* Formatting differences (whitespace, indentation) are ignored
* Attribute order in XML/HTML is normalized
* Key order in JSON/YAML is normalized
* Tests focus on content equality, not formatting
====


== Command-line interface

=== Installation

After installing the gem, the `canon` command will be available:

[source,bash]
----
$ gem install canon
$ canon --help
----

=== Format command

The `format` command formats files in XML, HTML, JSON, or YAML.

==== Output modes

`pretty` (default):: Human-readable output with indentation (2 spaces default)
`c14n`:: Canonical form without indentation

==== Command syntax

[source,bash]
----
canon format FILE [OPTIONS]
----

==== Options

`-f, --format FORMAT`:: Specify format: `xml`, `html`, `json`, or `yaml`
(auto-detected from extension if not specified)

`-m, --mode MODE`:: Output mode: `pretty` (default) or `c14n`

`-i, --indent N`:: Indentation spaces for pretty mode (default: 2)

`--indent-type TYPE`:: Indentation type: `space` (default) or `tab`

`-o, --output FILE`:: Write output to file instead of stdout

`-c, --with-comments`:: Include comments in canonical XML output

==== Examples

[source,bash]
----
# Pretty-print (default mode)
$ canon format input.xml
<?xml version="1.0" encoding="UTF-8"?>
<root>
  <a>1</a>
  <b>2</b>
</root>

# Canonical mode (compact)
$ canon format input.xml --mode c14n
<root><a>1</a><b>2</b></root>

# Custom indentation
$ canon format input.xml --mode pretty --indent 4
$ canon format input.json --indent 4

# Tab indentation
$ canon format input.xml --indent-type tab
$ canon format input.html --mode pretty --indent-type tab

# Specify format explicitly
$ canon format data.txt --format xml

# Save to file
$ canon format input.xml --output formatted.xml

# Include XML comments in canonical output
$ canon format doc.xml --mode c14n --with-comments

# HTML files
$ canon format page.html
$ canon format page.html --mode c14n
----

==== Format detection

[cols="1,1"]
|===
|File Extension |Detected Format

|`.xml`
|XML

|`.html`, `.htm`
|HTML

|`.json`
|JSON

|`.yaml`, `.yml`
|YAML
|===

=== Diff command

Compare two files after canonicalizing them.

==== Command syntax

[source,bash]
----
canon diff FILE1 FILE2 [OPTIONS]
----

==== Options

`-f, --format FORMAT`:: Format for both files: `xml`, `html`, `json`, or `yaml`

`--format1 FORMAT`:: Format for first file

`--format2 FORMAT`:: Format for second file

`--color / --no-color`:: Enable/disable colored output (default: enabled)

`-c, --with-comments`:: Include comments in canonical XML comparison

==== Examples

[source,bash]
----
# Compare two XML files
$ canon diff file1.xml file2.xml

# Compare with explicit format
$ canon diff data1.txt data2.txt --format xml

# Compare different formats
$ canon diff data.xml data.json --format1 xml --format2 json

# Compare HTML files
$ canon diff page1.html page2.html

# Disable colors
$ canon diff file1.xml file2.xml --no-color
----

==== Exit codes

* `0` - Files are canonically equivalent
* `1` - Files differ


== Development

After checking out the repo, run `bin/setup` to install dependencies. Then, run
`rake spec` to run the tests. You can also run `bin/console` for an interactive
prompt that will allow you to experiment.


== Contributing

Bug reports and pull requests are welcome on GitHub at
https://github.com/lutaml/canon.


== Copyright and license

Copyright Ribose.
https://opensource.org/licenses/BSD-2-Clause[BSD-2-Clause License].
