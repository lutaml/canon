= Canon: Canonicalization for serialization formats

A Ruby library for canonicalizing and pretty-printing XML, YAML, and JSON with
RSpec matchers for equivalence testing.


== Purpose

This gem provides `Canon` which is a library for canonicalizing and
pretty-printing various serialization formats (XML, YAML, JSON). It provides a
standardized form suitable for comparison and testing.


== Features

=== XML canonicalization

Format XML documents according to the
https://www.w3.org/TR/xml-c14n11/[W3C Canonical XML Version 1.1] specification.

Key features:

* Namespace declaration ordering (lexicographic by prefix)
* Attribute ordering (lexicographic by namespace URI, then local name)
* Character encoding normalization to UTF-8
* Special character encoding in text and attributes
* Removal of superfluous namespace declarations
* Support for xml:base, xml:lang, xml:space, and xml:id attributes
* Processing instruction and comment handling
* Document subset support with attribute inheritance

=== YAML canonicalization

Format YAML documents with keys sorted alphabetically at all levels of the
structure.

=== JSON canonicalization

Format JSON documents with keys sorted alphabetically at all levels of the
structure.

=== Output modes

Canon supports two output modes for all formats:

`c14n` (canonical):: Compact output without indentation, suitable for digital
signatures, hashing, and equivalence testing. Removes formatting whitespace.

`pretty` (pretty-print):: Human-readable output with consistent indentation.
Configurable indent size and type (spaces or tabs). This is the default mode for
CLI commands.

=== RSpec matchers

Provides matchers for testing equivalence between serialized formats.

NOTE: RSpec matchers always use canonical (c14n) mode for comparison to ensure
formatting differences don't affect test results.

=== Unified interface

Single API for working with all three formats.


== Installation

Add this line to your application's Gemfile:

[source,ruby]
----
gem 'canon'
----

And then execute:

[source,bash]
----
$ bundle install
----

Or install it yourself as:

[source,bash]
----
$ gem install canon
----


== Usage

=== Ruby API

==== Basic formatting (c14n mode)

The `Canon.format` method produces canonical output by default.

Syntax:

[source,ruby]
----
Canon.format({content}, {format})
Canon.format_{format}({content})  # Format-specific shorthand
----

Where,

`{content}`:: is the input string
`{format}`:: is the format type, which can be `:xml`, `:yaml`, or `:json`.

.Canonical formatting examples
[example]
====
[source,ruby]
----
require 'canon'

# XML - compact canonical form
xml = '<root><b>2</b><a>1</a></root>'
Canon.format(xml, :xml)
# => "<root><a>1</a><b>2</b></root>"

Canon.format_xml(xml)  # Shorthand
# => "<root><a>1</a><b>2</b></root>"

# JSON - canonical with sorted keys
json = '{"z":3,"a":1,"b":2}'
Canon.format(json, :json)
# => {"a":1,"b":2,"z":3}

# YAML - canonical with sorted keys
yaml = "z: 3\na: 1\nb: 2"
Canon.format(yaml, :yaml)
----
====

==== Pretty-print mode

For human-readable output with indentation, use the format-specific pretty
printer classes.

Syntax:

[source,ruby]
----
Canon::{Format}::PrettyPrinter.new(indent: {n}, indent_type: {type}).format({content})
----

Where,

`{Format}`:: The format module (`Xml`, `Html`, `Json`)
`{n}`:: Number of spaces (default: 2) or tabs (use 1 for tabs)
`{type}`:: Indentation type: `'space'` (default) or `'tab'`
`{content}`:: The input string

.Pretty-print examples
[example]
====
[source,ruby]
----
require 'canon/xml/pretty_printer'
require 'canon/json/pretty_printer'

xml_input = '<root><b>2</b><a>1</a></root>'

# XML with 2-space indentation (default)
Canon::Xml::PrettyPrinter.new(indent: 2).format(xml_input)
# =>
# <?xml version="1.0" encoding="UTF-8"?>
# <root>
#   <a>1</a>
#   <b>2</b>
# </root>

# XML with 4-space indentation
Canon::Xml::PrettyPrinter.new(indent: 4).format(xml_input)

# XML with tab indentation
Canon::Xml::PrettyPrinter.new(
  indent: 1,
  indent_type: 'tab'
).format(xml_input)

# JSON with 2-space indentation
json_input = '{"z":3,"a":{"b":1}}'
Canon::Json::PrettyPrinter.new(indent: 2).format(json_input)

# JSON with tab indentation
Canon::Json::PrettyPrinter.new(
  indent: 1,
  indent_type: 'tab'
).format(json_input)
----
====

==== Parsing

The `Canon.parse` method parses content into Ruby objects or Nokogiri documents.

Syntax:

[source,ruby]
----
Canon.parse({content}, {format})
Canon.parse_{format}({content})  # Format-specific shorthand
----

Where,

`{content}`:: The input string
`{format}`:: The format type (`:xml`, `:html`, `:json`, or `:yaml`)

.Parsing examples
[example]
====
[source,ruby]
----
# Parse XML → Nokogiri::XML::Document
xml_doc = Canon.parse(xml_input, :xml)
xml_doc = Canon.parse_xml(xml_input)

# Parse JSON → Ruby Hash/Array
json_obj = Canon.parse(json_input, :json)
json_obj = Canon.parse_json(json_input)
# => Ruby object (Hash, Array, etc.)
----
====
[source,ruby]
----
# Parse XML
xml_doc = Canon.parse(xml_input, :xml)
xml_doc = Canon.parse_xml(xml_input)
# => Nokogiri::XML::Document

# Parse YAML → Ruby Hash/Array
yaml_obj = Canon.parse(yaml_input, :yaml)
yaml_obj = Canon.parse_yaml(yaml_input)
# => Ruby object (Hash, Array, etc.)

# Parse JSON
json_obj = Canon.parse(json_input, :json)
json_obj = Canon.parse_json(json_input)
# => Ruby object (Hash, Array, etc.)
----
====


=== RSpec matchers

RSpec matchers for testing equivalence between serialized formats. All matchers
use canonical (c14n) mode for comparison.

.RSpec matcher examples
[example]
====
[source,ruby]
----
require 'rspec'
require 'canon'

RSpec.describe 'Serialization equivalence' do
  # Unified matcher with format parameter
  it 'compares XML' do
    xml1 = '<root><a>1</a><b>2</b></root>'
    xml2 = '<root>  <b>2</b>  <a>1</a>  </root>'
    expect(xml1).to be_serialization_equivalent_to(xml2, format: :xml)
  end

  it 'compares equivalent YAML' do
    yaml1 = "---\na: 1\nb: 2\n"
    yaml2 = "---\nb: 2\na: 1\n"
    expect(yaml1).to be_serialization_equivalent_to(yaml2, format: :yaml)
  end

  it 'compares JSON' do
    json1 = '{"a":1,"b":2}'
    json2 = '{"b":2,"a":1}'
    expect(json1).to be_serialization_equivalent_to(json2, format: :json)
  end

  it 'compares YAML' do
    yaml1 = "a: 1\nb: 2"
    yaml2 = "b: 2\na: 1"
    expect(yaml1).to be_serialization_equivalent_to(yaml2, format: :yaml)
  end

  # Format-specific matchers
  it 'uses format-specific matchers' do
    expect(xml1).to be_xml_equivalent_to(xml2)    # XML
    expect(xml1).to be_analogous_with(xml2)       # XML (legacy)
    expect(json1).to be_json_equivalent_to(json2) # JSON
    expect(yaml1).to be_yaml_equivalent_to(yaml2) # YAML
  end
end
----
====

[IMPORTANT]
====
RSpec matchers always canonicalize both sides before comparing, so:

* Formatting differences (whitespace, indentation) are ignored
* Attribute order in XML/HTML is normalized
* Key order in JSON/YAML is normalized
* Tests focus on content equality, not formatting
====


== Command-line interface

=== Installation

After installing the gem, the `canon` command will be available:

[source,bash]
----
$ gem install canon
$ canon --help
----

=== Format command

The `format` command formats files in XML, HTML, JSON, or YAML.

==== Output modes

`pretty` (default):: Human-readable output with indentation (2 spaces default)
`c14n`:: Canonical form without indentation

==== Command syntax

[source,bash]
----
canon format FILE [OPTIONS]
----

==== Options

`-f, --format FORMAT`:: Specify format: `xml`, `html`, `json`, or `yaml`
(auto-detected from extension if not specified)

`-m, --mode MODE`:: Output mode: `pretty` (default) or `c14n`

`-i, --indent N`:: Indentation spaces for pretty mode (default: 2)

`--indent-type TYPE`:: Indentation type: `space` (default) or `tab`

`-o, --output FILE`:: Write output to file instead of stdout

`-c, --with-comments`:: Include comments in canonical XML output

==== Examples

[source,bash]
----
# Pretty-print (default mode)
$ canon format input.xml
<?xml version="1.0" encoding="UTF-8"?>
<root>
  <a>1</a>
  <b>2</b>
</root>

# Canonical mode (compact)
$ canon format input.xml --mode c14n
<root><a>1</a><b>2</b></root>

# Custom indentation
$ canon format input.xml --mode pretty --indent 4
$ canon format input.json --indent 4

# Tab indentation
$ canon format input.xml --indent-type tab
$ canon format input.html --mode pretty --indent-type tab

# Specify format explicitly
$ canon format data.txt --format xml

# Save to file
$ canon format input.xml --output formatted.xml

# Include XML comments in canonical output
$ canon format doc.xml --mode c14n --with-comments

# HTML files
$ canon format page.html
$ canon format page.html --mode c14n
----

==== Format detection

[cols="1,1"]
|===
|File Extension |Detected Format

|`.xml`
|XML

|`.html`, `.htm`
|HTML

|`.json`
|JSON

|`.yaml`, `.yml`
|YAML
|===

=== Diff command

Compare two files after canonicalizing them.

==== Command syntax

[source,bash]
----
canon diff FILE1 FILE2 [OPTIONS]
----

==== Options

`-f, --format FORMAT`:: Format for both files: `xml`, `html`, `json`, or `yaml`

`--format1 FORMAT`:: Format for first file

`--format2 FORMAT`:: Format for second file

`--color / --no-color`:: Enable/disable colored output (default: enabled)

`-c, --with-comments`:: Include comments in canonical XML comparison

==== Examples

[source,bash]
----
# Compare two XML files
$ canon diff file1.xml file2.xml

# Compare with explicit format
$ canon diff data1.txt data2.txt --format xml

# Compare different formats
$ canon diff data.xml data.json --format1 xml --format2 json

# Disable colors
$ canon diff file1.xml file2.xml --no-color
----

==== Exit codes

* `0` - Files are canonically equivalent
* `1` - Files differ


== Development

After checking out the repo, run `bin/setup` to install dependencies. Then, run
`rake spec` to run the tests. You can also run `bin/console` for an interactive
prompt that will allow you to experiment.


== Contributing

Bug reports and pull requests are welcome on GitHub at
https://github.com/lutaml/canon.


== Copyright and license

Copyright Ribose.
https://opensource.org/licenses/BSD-2-Clause[BSD-2-Clause License].
